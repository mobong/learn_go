#### 变量：
    
    变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。
#### 类型：

    变量或表达式的类型定义了对应存储值的属性特征，在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳。
    一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。
#### 指针：

    一个变量对应一个保存了变量对应类型值的内存空间。
    一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。
    如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。
#### 整数：

    Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
    还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。
#### 浮点数：

    正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1);在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示。
#### 常量：

    Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
    注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。
#### 数组：

    当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。
#### Slice(切片):

    由三个部分组成：指针、长度、容量(cap)。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。
    和数组不同，slice不能进行比较；原因一，一个slice的元素是间接引用的，一个slice甚至可以包含自身(译注：当slice声明为[]interface{}时，slice的元素可以是自身);原因二，因为slice的元素是间接引用的，一个固定的slice值(译注：指slice本身的值，不是元素的值)在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。唯一合法的操作就是跟 nil 值作比较。
    切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改（切片操作并不复制切片指向的元素。它创建一个新的切片并复用原来切片的底层数组。 这使得切片操作和数组索引一样高效。因此，通过一个新切片修改元素会影响到原始切片的对应元素）。
    var s1 []int 为nil，var s1 []int{} 或 var s1 = make([]int 0) 或 var s1 []int = make([]int, 0) 不为nil。

* 可能的陷阱:正如前面所说，切片操作并不会复制底层的数组。整个数组将被保存在内存中，直到它不再被引用。 有时候可能会因为一个小的内存引用导致保存所有的数据。

例如， FindDigits 函数加载整个文件到内存，然后搜索第一个连续的数字，最后结果以切片方式返回。
```go
var digitRegexp = regexp.MustCompile("[0-9]+")

func FindDigits(filename string) []byte {

b, _ := ioutil.ReadFile(filename)

return digitRegexp.Find(b)

}
```
这段代码的行为和描述类似，返回的 []byte 指向保存整个文件的数组。因为切片引用了原始的数组， 导致 GC 不能释放数组的空间；只用到少数几个字节却导致整个文件的内容都一直保存在内存里。

要修复整个问题，可以将感兴趣的数据复制到一个新的切片中：
```go
func CopyDigits(filename string) []byte {

b, _ := ioutil.ReadFile(filename)

b = digitRegexp.Find(b)

c := make([]byte, len(b))

copy(c, b)

return c

}

```
#### Map(映射)：

    map中的元素并不是一个变量，因此不能对map的元素进行取址操作。禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。
    大部分操作(跟slice一样可以)，包括查找、删除、len和range循环都可以安全工作在nil值的maph ，它们的行为和一个空的map类似。唯一不同的是向一个nil值的map存入元素将导致一个panic异常，因此需要在向map存数据前先创建map。
    map不是并发安全的，需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版sync.Map。
    map在函数/方法内更新整个map是无效的，只能操作(更新、删除、增加) map里面的值，因为传入的是一个变量的内存地址(指针所在别名)

#### Struct(结构体)：

    结构体的成员输入顺序不同，相当于定义了不同的结构体类型。
    一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。(该限制同样适用于数组)但是该S类型的结构体可以包含*S指针类型的成员。

    匿名成员：只声明一个成员对应的数据类型而不指名成员的名字。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。
#### Func(函数)：

    调用函数返回的是值，并不是一个可取地址的变量
    函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表的中变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响他们是否可以以省略参数类型的形式表示。
    大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题。
    在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。
    函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。
    函数值可以与nil比较，但是函数值之间是不可比较的，也不能用函数值作为map的key。

* 拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可以绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法跟函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。

* 函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在着变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。

* 当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 var visitAll func()），再将匿名函数赋值给这个变量。如果不分成两步，函数字面量无法与visitAll绑定，我们也无法递归调用该匿名函数。

Deferred函数：

    只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束,还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。
#### 方法：

* 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

* 我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者interface（就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法）。在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的。


* nil是一个合法的接收器类型，就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice.

在每一个合法的方法调用表达式中，也就是下面三种情况里的什么问题一种情况都是可以的：

    1）接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型\*T;

    2）接收器实参是类型T，但接收器形参是类型\*T，这种情况下编译器会隐式地为我们取变量的地址；

    3）接收器实参是类型\*T，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量。


* 在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（译注：访问需要通过该指针指向的对象去取）。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之前的关系。

* 封装提供了三方面的优点。首先，因为调用主不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。第二，隐藏实现的细节 ，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。第三，也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。

* 方法值，一个将方法(Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器（译注：因为已经在方法值中指定过了），只要传入函数的参数即可。

* 和方法值相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（p.Distance）语法来指定方法的接收器。当T是一个类型时，方法表达式可能会写作 T.f 或者 (*T).f，会返回一个函数值，这种函数会将其第一个参数用作接收器，所以可以用通常(不写接收器)的方法来对其进行调用。

#### 接口：

* 接口类型是对其他类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起。
* 接口调用不会做receiver的自动转换。
* 接口类型描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口的实例。
* 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。
* 接口类型封装和隐藏具体类型和它的值。interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以可以将任意一个值赋给空接口类型。
* 接口值由两个部分组成，一个具体的类型和那个类型的值，它们被称为接口的动态类型和动态值。接口值可以使用==和!=来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。然而，如果 两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如slice、映射类型、函数），将它们进行比较就会失败并且panic。
* 一个包含nil指针的接口不是nil接口（即非空接口），一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。
* 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个具体方法的类型。

#### 类型断言
* 是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
* 第一种，如果断言的类型T是一个具体类型，然后类型断言检查 x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值(即获取到相应的变量值)。
```go
var w io.Writer
w = os.Stdout
f := w.(*os.File) // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
```
* 第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查 是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。
```go
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
```
* 如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它就像是赋值操作一样，除了对于nil接口值的情况。

* 类型分支，接口被以两种不同的方式使用：一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作（以io.Reader，io.Writer和error等为典型）。另一个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体要求的类型满足这个接口，而不在于接口的方法，并且没有任何的信息隐藏。相似的type switch（类型分支）可以简化类型断言的if-else链，运算对象是x.(type)--它使用了关键词字面量type--并且每个case有一到多个类型，每个case也会隐式的创建一个单独的词法块。

#### Goroutines和channels:
* go后跟的函数的参数会在go语句自身执行时被求值。
* 和map类似，channel也对应一个make创建的底层数组结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用一个channel对象。channel的零值也是nil。两个相同类型的channel也可以用==运算符比较。
* Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。
* 没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。 例: x, ok := <-naturals

* 当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致Panic异常。关闭一个channels还会触发一个广播机制。

#### 不带缓存的Channels:
* 一个基于无缓存Channels的发送操作将导致发送者goroutime阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个groutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
* 基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前（happens befor,这是Go语言并发内存模型的一个关键术语！）。
* Channels也可以用于将多个gorutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。

#### 单方向channe：

* 当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan\<- int 表示一个只发送int的channel（即发送int数据给channel），只能发送不能接收。相反，类型\<-chan int 表示一个只接收int的channel（即从channel那边接收int数据），只能接收不能发送。

* 带缓存的channel是一个缓存队列，先进先出。如果带缓存的goroutines没有接收而被永远卡住，或者这个goroutine还依然存活，继续 徒劳地尝试向channel中发送值，然而这时候已经没有其他的goroutine会从该channel中接收值了，称为goroutines泄漏。和垃圾变量不同，泄漏的goroutines并不会被自动回收。

#### 基于select的多路复用(跟channel合用)：

* select会等case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其他通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。

* select有一个default来设置当其他的操作都不能够马上被处理时程序需要执行哪些逻辑。下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做"轮询channel"。

* channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。

#### 基于共享变量的并发：

* 包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制 在单一的goroutine，所以修改这些变量"必须"使用互斥条件。竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果 。

* 数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有三种方式可以避免数据竞争：第一种方法是不要去写变量；第二种方法是避免从多个goroutine访问变量（不要使用共享数据来通信；使用通信来共享数据。一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的monitor(监控)goroutine）；第三种方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问，这种方式被称为"互斥"。

* 可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量（binary semaphore）。sync.Mutex会保护共享变量。惯例来说，被mutex所保护的变量是在mutex变量声明之后立刻声明。在Lock和Unlock之间的代码段中的内容goroutine可以随便读取或者修改，这个代码段叫做临界区。

* 特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作"多读单写"锁（multiple reader,single writer lock），Go语言提供的这样的锁是sync.RWMutex。RLock只能在临界区共享变量没有任何写入操作时可用。RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。

* sync.Once：概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数。

#### Goroutines和线程:

* 动态栈：每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用 其他函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。goroutine的栈的最大值有1GB.

* Goroutine调度：OS线程会被操作系统内核调试。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会的挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个"移动"需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调试器的数据结构 。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。 go的运行时包含了其自己的调试器，这个调试器使用了一些技术手段，比如m:n调试，因为其会在n个操作系统线程上多工（调度）m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（按程序独立）。 和操作系统的线程调度不同的是，Go调试器并不是用一个硬件定时器，而是被Go语言"建筑"本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调试或者mutex操作阻塞时，调试器会使其进入休眠并执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。

* GOMAXPROCS:Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。（GOMAXPROCS是前面说的m:n调试中的n）。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调试的。可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。

#### 包

* 包的初始化首先解决包级变量的依赖顺序 ，然后按照包级变量声明出现的顺序依次初始化：
```go 
var a = b + c // a 第三个初始化, 为 3
var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1 // c 第一个初始化, 为 1
func f() int { return c + 1 }
```
* 对于在包级别声明的变量，如果有初始化表达式则用表达工初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数，这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

#### 反射

* Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。

* 反射是由reflect包提供的。它定义了两个重要的类型，Type和Value。一个Type表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。

* reflect包中另一个重要的类型是Value。一个reflect.Value可以装载任意类型的值。函数reflect.ValueOf接受任意的interface{}类型，并返回一个装载着其动态值的reflect.Value。和reflect.TypeOf类似，reflect.ValueOf返回的结果也是具体的类型，但是reflect.Value也可以持有一个接口值 。对Value调用 Type方法将返回具体类型对应的reflect.Type：
```go
t := v.Type() // a reflect.Type
fmt.Println(t.String()) // "int"
```
* reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法。它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值：
```go
v := reflect.ValueOf(3) // a reflect.Value
x := v.Interface() // an interface{}
i := x.(int) // an int
fmt.Printf("%d\n", i) // "3"
```
* reflect.Value和interface{}都能装载任意的值。所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值，内部值我们没法访问。

* 所有通过reflect.ValueOf(X)返回的reflect.Value都是不可取地址的。但是通过reflect的解引用方式生成的，却是指向另一个变量，因此是可取地址（[通过reflect.Value修改值](https://books.studygolang.com/gopl-zh/ch12/ch12-05.html)）。

反射需要小心使用，原因有三。

* 第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写代码很久之后了，而且程序也可能运行了很长的时间。 避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。

* 避免反射的第二原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。

* 第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。

#### unsafe包

* unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。

* Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8字节。

* 由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。

| 类型 | 大小 |
| --- | --- |
| bool | 1个字节 |
| intN, uintN, floatN, complexN | N/8个字节（例如float64是8个字节） |
| int, uint, uintptr | 1个机器字 |
| \*T | 1个机器字 |
| string | 2个机器字（data、len） |
| []T | 3个机器字（data、len、cap） |
| map | 1个机器字 |
| func | 1个机器字 |
| chan | 1个机器字 |
| interface | 2个机器字（type、value） |

* unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数。和 Sizeof 类似， Alignof 也是返回一个常量表达式，对应一个常量。通常情况下布尔和数字类型需要对齐到它们本身的大小（最多8个字节），其它的类型对齐到机器字大小。

* unsafe.Offsetof 函数的参数必须是一个字段 x.f，然后返回 f 字段相对于 x 起始地址的偏移量，包括可能的空洞。
